## Практическое задание на тему "Генерация имени функции по ее телу"

### Описание задания

Цель данного задания - разработать программное решение на языке Python для
предсказания имен функций на основе анализа их тел. Вы будете работать с
реальными данными из репозиториев исходного кода и использовать современные
предобученные модели небольшого размера для решения этой задачи.

Пример:

```python
def some_function(x):
    """Increases each number in the given list by 1."""
    return [i + 1 for i in x]
```

Для этой функции логичное имя могло бы быть что-то вроде
`increment_list_elements`.

В данном примере функция принимает список целых чисел, увеличивает каждое число
на 1 и возвращает новый список. Документация также предоставляет полезную
информацию о функции, что может быть использовано моделью для предсказания
подходящего имени.

### Зависимости

Аналогично первому заданию, для работы вам понадобятся:

1. `Python >=3.10`
2. `pip3` совместимый с установленной версией языка `Python`
3. `venv` модуль для установки виртуальных окружений

Для установки:

1. Создайте виртуальное окружение `python3.10 -m venv venv` и активируйте его
   `source venv/bin/activate`.
2. Установите зависимости `pip install -r requirements.txt -r
   requirements_dev.txt`

После этого можно использовать основную точку входа `main.py` и ее подкоманды.
Смотрите `python main.py --help` для справки.

Вы также можете выполнять задание в ipython notebook'ах или Google Colab'е.

### Подзадача 1: Подготовка набора данных

#### Описание

**Цель**: Создание и подготовка набора данных, содержащего тела функций, их
имена, документацию и комментарии из открытых репозиториев.

**Основные инструменты**:
- [**tree-sitter**](https://tree-sitter.github.io/tree-sitter/) библиотека для
  синтаксического разбора исходного кода, поддерживающая множество языков
  программирования.
- [**py-tree-sitter**](https://github.com/tree-sitter/py-tree-sitter) интерфейс
  к библиотеке tree-sitter для языка Python
- [**huggingface datasets**](https://huggingface.co/docs/datasets/index)
  библиотека из экосистемы Hugging Face для работы с различными наборами данных

В качестве датасета будет использоваться
[**CodeSearchNet**](https://huggingface.co/datasets/code-search-net/code_search_net):
набор данных, содержащий исходный код на различных языках программирования. Из
него вам понадобятся только части для языка Python.

#### Шаги выполнения

1. Установите и настройте библиотеку tree-sitter для синтаксического анализа
   кода на Python и необходимые файлы для языка (пакеты tree-sitter и
   tree-sitter-python).

2. Загрузите данные из CodeSearchNet и проанализируйте их структуру
   (используйте `load_dataset` из библиотеки datasets из экосистемы
   HuggingFace, потребуется использовать флаг `trust_remote_code=True`, не
   забудьте выбрать язык python, в качестве аргумента `split`можно сразу
   передать `test`). В процессе выполнения задания можно ограничить количество
   примеров, например, до первой 1000.

3. С помощью библиотеки tree-sitter выполните синтаксический разбор полей
   `whole_func_string` и реализуйте извлечения следующих элементов из
   построенных деревьев:
    - имя функции
    - тело функции без комментариев и документации
    - тело функции с комментариями с документацией (docstrings)

   Реализация может быть выполнена, с помощью обходчика синтаксического дерева
   (AST-Visitor) или с использованием query API библиотеки tree-sitter. При
   реализации вам также пригодиться [интерактивная
   песочница](https://tree-sitter.github.io/tree-sitter/playground).

   К примеру для такой функции:
   ```python
   def sina_xml_to_url_list(xml_data):
       """str->list
       Convert XML to URL List.
       From Biligrab.
       """
       rawurl = []
       # Comment1
       # Comment 2
       dom = parseString(xml_data)
       for node in dom.getElementsByTagName('durl'):
           url = node.getElementsByTagName('url')[0]  # Comment 3
           rawurl.append(url.childNodes[0].data)
       return rawurl
   ```

   требуется извлечь имя `sina_xml_to_url_list`, тело без комментариев:

   ```python
       rawurl = []
       dom = parseString(xml_data)
       for node in dom.getElementsByTagName('durl'):
           url = node.getElementsByTagName('url')[0]
           rawurl.append(url.childNodes[0].data)
       return rawurl
   ```

   и тело с комментариями:
   ```python
       """str->list
       Convert XML to URL List.
       From Biligrab.
       """
       rawurl = []
       # Comment1
       # Comment 2
       dom = parseString(xml_data)
       for node in dom.getElementsByTagName('durl'):
           url = node.getElementsByTagName('url')[0]  # Comment 3
           rawurl.append(url.childNodes[0].data)
       return rawurl
   ```
4. Добавьте дополнительные поля в исходный датасет с вышеуказанными элементами

5. Приведите примеры извлеченных функций

6. Для проверки корректности извлечения сравните извлеченные имена с полем
   `func_name`, документацию с полем `func_documentation_string` в исходном
   датасете. Имейте ввиду, что оригинальное поле `func_name` содержит полное
   квалифицированное имя (`ClassA.foo`), в задании этого не требуется, можно
   ограничиться просто именем (`foo`).

### Подзадача 2: Использование предобученных моделей для предсказания имен функций

#### Описание

1. **Цель**: Использовать предобученную модель для предсказания имен функций по
   их телам.

2. **Модели** на выбор:
    - [**CodeT5+**](https://huggingface.co/Salesforce/codet5p-220m):
      предобученная модель трансформер семейства T5 для задач обработки
      исходного кода. Эта модель предполагает решение задачи code-infilling,
      т.е. вам потребуется заменить имя функции специальным токеном
      `<extra_id_i>`, см аналогичный пример для генерации тела функции.

    - [**CodeBERT**](https://huggingface.co/microsoft/codebert-base):
      предобученная модель трансформер семейства BERT, адаптированная для
      работы с исходным кодом.

    - другие модели для исходного кода на ваш выбор

#### Шаги выполнения

##### Использование предобученных моделей только на исходном коде

1. Загрузите предобученную модель (например, CodeT5+)

2. Используйте подготовленный на первом этапе датасет, содержащий только тела
   функций без каких либо комментариев и их имена, для предсказания имен
   функций.

3. Оцените результаты работы моделей без тонкой настройки, используя метрики
   качества Exact Match (полное совпадение) и ROUGE-score (можно использовать
   реализацию из библиотеки
   [evaluate](https://huggingface.co/docs/evaluate/index)
   `evaluate.load('exact_match'), evaluate.load('rouge')`. Показатель EM на
   первой 1000 примеров тестовой выборки должен быть в окрестности 0.145;
   ROUGE-1 в окрестности 0.38.

##### Использование предобученных моделей на исходном коде, документации и комментариях

1. Загрузите предобученную модель (например, CodeT5+)

2. Используйте подготовленный на первом этапе датасет, содержащий тела функций,
   их имена, документацию и комментарии.

3. Оцените результаты работы моделей без тонкой настройки на таких расширенных
   примерах с использованием тех же метрик. Показатель EM на первой 1000
   примеров тестовой выборки должен быть в окрестности 0.209; ROUGE-1 в
   окрестности 0.49.

4. Анлогично первому практическому заданию подготовьте краткий отчет, который
   будет включать сравнение по метрикам Exact Match и ROUGE-score результатов
   работы с использованием документации и комментариев с результатами,
   полученными только на основе исходного кода. В отчет также включите анализ
   небольшого числа примеров с наихудшими значениями метрик.


### Сроки выполнения

Общий срок выполнения задания: 2 недели
